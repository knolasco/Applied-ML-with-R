---
title: "Imputing with imputeTS"
author: "Kevin Nolasco"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### Load Libraries

```{r, results = FALSE}
library(imputeTS) # for imputation functions and dataset
library(glue) # to format printing
library(ggpubr) # for plotting multiple plots
```


### Load Data

```{r}
# load dataset ----
data_with_na <- tsNH4
data_complete <- tsNH4Complete
```

## Hypothesis

According to the documentation for imputeTS, the tsNH4 dataset is a time-series NH4 concentration in a waste-water system. Since this is a time series dataset, I believe seasonality will play a big role on the way the dataset behaves. Therefore, a simple imputation method - such as using the mean, median, or mode will not be sufficient to capture the trend of the data. I believe the best method for imputing this dataset will be an interpolation model with spline or Stineman Interpolation.

We will test three interpolation functions (na_interpolation, na_kalman, and na_seadec) and we will tweak each parameters for the best result. For example, we will impute using na_interpolation with linear, 
spline, and stine interpolation.

The results of the imputations will be evaluated using RMSE (root mean squared error).

## Data Visualization
Let's see what the dataset looks like, and how many missing values there are.

```{r}
ggplot_na_distribution(data_with_na)

```

We can visually see that there are a lot of missing values. Let's get a concrete set of how many values we are dealing with using the stats package included in imputeTS.

```{r}
statsNA(data_with_na)
```

From the stats output, we can see the dataset consists of 4,552 data points with 883 missing values (19.4% of values are missing).

# Impute Values

## na_interpolation

```{r}
na_interpolation_results <- function(dataset, dataset_no_missing){
  # impute
  with_linear <- na_interpolation(dataset, option = "linear")
  with_spline <- na_interpolation(dataset, option = "spline")
  with_stine <- na_interpolation(dataset, option = "stine")
  
  datasets <- list(with_linear, with_spline, with_stine)
  names <- list("Linear", "Spline", "Stine")
  all_rmse <- c()
  # calculate and print rmse's
  for(ind in 1:3){
    name <- names[[ind]]
    data <- datasets[[ind]]
    rmse <- sqrt(mean((data - dataset_no_missing)^2))
    print(glue("RMSE for {name} Imputation : {rmse}"))
    all_rmse <- c(all_rmse, rmse)
  }
  # print method with lowest rmse
  min_ind <- which.min(all_rmse)
  lowest_rmse <- all_rmse[min_ind]
  name_lowest_rmse <- names[[min_ind]]
  print(glue("{name_lowest_rmse} Imputation had the lowest RMSE of: {lowest_rmse}"))
  return(datasets)
}
imputed_datasets <- na_interpolation_results(data_with_na, data_complete)
```

Based on the analysis above, we could see that the linear interpolation worked best for imputing this dataset. My hypothesis was that the spline or Stineman interpolation would work best. From my understanding, spline uses a polynomial function to approximate the next data point, this could why the interpolation did not work well. There is a chance that the interpolating polynomial was estimated with a high degree. Models using high degree polynomials have high variance, which explains the higher RMSE's.

Let's plot the imputed values for each method.

```{r}
ggplot_na_imputations(data_with_na, imputed_datasets[[1]], data_complete, title = "Linear Imputations")

ggplot_na_imputations(data_with_na, imputed_datasets[[2]], data_complete, title = "Spline Imputations")

ggplot_na_imputations(data_with_na, imputed_datasets[[3]], data_complete, title = "Stineman Imputations")

```

From the plots above, we can see the imputed values for Spline interpolation between x = 1000 and x = 1500, the imputed values are very off from the actual values. This is probably due to the high degree polynomial that we discussed in the section before.

## na_kalman

According to the documentation, the kalman methods for imputing work better for datasets that contain seasonality. As we saw above, the dataset does contain some seasonality, so let's see how these imputation techniques do.

```{r}
na_kalman_results <- function(dataset, dataset_no_missing){
  # impute
  with_linear <- na_kalman(dataset, model =  "auto.arima")
  with_stine <- na_kalman(dataset, model = "StructTS")
  
  datasets <- list(with_linear, with_spline, with_stine)
  names <- list("Linear", "Spline", "Stine")
  all_rmse <- c()
  # calculate and print rmse's
  for(ind in 1:3){
    name <- names[[ind]]
    data <- datasets[[ind]]
    rmse <- sqrt(mean((data - dataset_no_missing)^2))
    print(glue("RMSE for {name} Imputation : {rmse}"))
    all_rmse <- c(all_rmse, rmse)
  }
  # print method with lowest rmse
  min_ind <- which.min(all_rmse)
  lowest_rmse <- all_rmse[min_ind]
  name_lowest_rmse <- names[[min_ind]]
  print(glue("{name_lowest_rmse} Imputation had the lowest RMSE of: {lowest_rmse}"))
  return(datasets)
```

